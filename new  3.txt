import java.awt.Polygon;
import java.awt.ArrayList;

public class maxAreaPolygon
{
	ArrayList<NodeWorld> potentialList;
	ArrayList<NodeWorld> vertexList;
	Polygon safeZone;
	double slope;
	double translation;
	public Polygon makePolygon(ArrayList<NodeWorld> nodeList)//draws the actual polygon
	{
	}
	public boolean pointsRemaining()//checks to see if there are points remaining
	{
		for(int i = 0; i < potentialList.size(); i++)
		{
			if(safeZone.inside(potentialList.get(i).x, potentialList.get(i).y))
			{
				potentialList.remove(i);
				i--;
			}
		}
		if(potentialList.size() > 0)
		{
			return true;
		}
		return false;
	}
	public void addFarthestPoint(String slope)
	{
		int farthstNodeIndex = 0;
		double farthestNode = 0;
		for(int i = 0; i < potentialList.size(); i++)
		{
			if(minDistance(potentialList.get(i).x, potentialList.get(i).y) > farthestNode)
			{
				farthestNodeIndex = i;
			}
		}
		vertexList.add(getVertexIndex(slope, potentialList.get(farthestNodeIndex)),potentiaList.get(farthestNodeIndex));
	}
	public int getVertexIndex(String slope, NodeWorld farthestNode)
	{
		//if translation is bigger, then it is more to the right
		//for the top left, and bottom left, to the right = add index after
		//for the top right and bottom right, to the right = add index before
		switch(slope)
		{
			case "BottomLeft": 
				//find the vertices between the two primes
				for(int i = firstPointIndex; i < secondPointIndex; i++)
				{
				}
			case "TopLeft":
			case "BottomRight":
			case "TopRight":
		}
		return index;
	}
	public double minDistance(int x0, int y0)
	{
		//formula
		double minDistance = Math.abs(y0 - (slope*x0) - translation)/Math.sqrt(slope*slope + 1);
		return minDistance;
	}
	/*
		//find slope
		double inverseSlope = -1/slope;
		//find translation of line
		double translation = y0 - inverseSlope*x0;
		//solve the two equations to find the point that intersects the perpendicular
		x1 = 
		y1 = 
		//find distance from point to the point that intersects the perpendicular
		derivation on here
	*/
}